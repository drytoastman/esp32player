
#include "ht16d35a.h"
#include "all.h"
#include "esp_rom_sys.h"

static char *TAG = "ht16d35a";
/*
Set COM output Control
Set ROW output Control
Set Binary/Gray mode
Set number of COM output
Set constant current ratio
Set global brightness control
Set system control
(System oscillator on)
*/
void ht16d35a_tx(spi_device_handle_t dev, char *tx, int tx_len, int display);
void ht16d35a_rx(spi_device_handle_t dev, char *rx, int *rx_len, int display);


char redmap[] = {
    0x80, 0x00,
    0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00,   0,0,0,0,
    0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00,   0,0,0,0,
    0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00,   0,0,0,0,
    0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00,   0,0,0,0,
    0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00,   0,0,0,0,
    0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00,   0,0,0,0,
    0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00,   0,0,0,0,
    //0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00,   0,0,0,0,
};


char bluemap[] = {
    0x80, 0x00,
    0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,   0,0,0,0,
    0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,   0,0,0,0,
    0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,   0,0,0,0,
    0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,   0,0,0,0,
    0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,   0,0,0,0,
    0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,   0,0,0,0,
    0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,   0,0,0,0,
    //0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00,   0,0,0,0,
};


void ht16d35a_init(spi_device_handle_t *dev) {
    ESP_LOGI(TAG, "Add device");

    ESP_ERROR_CHECK(spi_bus_add_device(VSPI_HOST, &(spi_device_interface_config_t) {
        .clock_speed_hz = 2000000,  // start conservative (e.g. 2 MHz)
        .mode = 0, // SPI,
        .spics_io_num = -1,
        .queue_size = 1,
        .flags = SPI_DEVICE_3WIRE | SPI_DEVICE_HALFDUPLEX,
        .command_bits = 0,
        .address_bits = 0
    }, dev));


    char com[] = {0x41, 0xFF}; // COM pin
    char row[] = {0x42, 0xFF, 0xFF, 0xFF, 0xFF}; // Row pins
    char gray[] = {0x31, 0x00};  // gray mode
    char cout[] = {0x32, 0x07};  // COM outputs scan
    char bright[] = {0x37, 0x40};  // brightness
    //0x36, 0x06,  // current
    char on[] = { 0x35, 0x03 };  // system on

    char everything[226] = {0};
    everything[0] = 0x80;
    everything[1] = 0x00; // start of data
    for (int ii = 2; ii < 226; ii+=4) {
        everything[ii] = 0x10;
    }


    for (int ii = 0; ii < 4; ii++) {
        ht16d35a_tx(*dev, gray, sizeof(gray), ii);
        ht16d35a_tx(*dev, com, sizeof(com), ii);
        ht16d35a_tx(*dev, row, sizeof(row), ii);
        ht16d35a_tx(*dev, cout, sizeof(cout), ii);
        ht16d35a_tx(*dev, bright, sizeof(bright), ii);
        ht16d35a_tx(*dev, on, sizeof(on), ii);
        vTaskDelay(pdMS_TO_TICKS(1));
    }

    ht16d35a_tx(*dev, redmap, sizeof(redmap), 0);
    ht16d35a_tx(*dev, bluemap, sizeof(bluemap), 1);
    ht16d35a_tx(*dev, redmap, sizeof(redmap), 2);
    ht16d35a_tx(*dev, bluemap, sizeof(bluemap), 3);
}


void ht16d35a_tx(spi_device_handle_t dev, char *tx, int tx_len, int display) {
    spi_transaction_t t = {
        .length = tx_len * 8,
        .tx_buffer = tx,
        .rx_buffer = NULL,
        .rxlength = 0
    };

    if (xSemaphoreTake(spi_bus_mutex, pdMS_TO_TICKS(MAX_SPI_WAIT_MS)) == pdTRUE) {
        display_cs(display, 0);
        ESP_ERROR_CHECK(spi_device_transmit(dev, &t));
        display_cs(display, 1);
        xSemaphoreGive(spi_bus_mutex);
    } else {
        ESP_LOGE(TAG, "Failed to acquire SPI bus mutex");
    }
}


void ht16d35a_rx(spi_device_handle_t dev, char *rx, int *rx_len, int display) {
    int response_code;
    char read[2] = {0x81, 0x00};
    char output[60];

    spi_transaction_t t = {
        .length = 2 * 8,
        .tx_buffer = &read,
        .rx_buffer = output,
        .rxlength = 60 * 8
    };

    if (xSemaphoreTake(spi_bus_mutex, pdMS_TO_TICKS(MAX_SPI_WAIT_MS)) == pdTRUE) {
        memset(output, 0, sizeof(output));
        display_cs(display, 0);
        ESP_ERROR_CHECK(spi_device_transmit(dev, &t));
        display_cs(display, 1);
        xSemaphoreGive(spi_bus_mutex);

        for (int ii = 0; ii < 60; ii++) {
            ESP_LOGI(TAG, "%d,%d: 0x%X", display, ii, output[ii]);
        }
    } else {
        ESP_LOGE(TAG, "Failed to acquire SPI bus mutex");
    }
}

int whack = 2;
void ht16d35a_try(spi_device_handle_t dev, int val) {

    char everything[226] = {0};
    everything[0] = 0x80;
    everything[1] = 0x00; // start of data

    ht16d35a_tx(dev, everything, sizeof(everything), 0);
    ht16d35a_tx(dev, everything, sizeof(everything), 1);
    ht16d35a_tx(dev, everything, sizeof(everything), 2);
    ht16d35a_tx(dev, everything, sizeof(everything), 3);

    for (int ii = 2; ii < 226; ii++) {
        everything[ii] = 0x00;
    }
    everything[whack] = 0x10;
    whack++;

    ht16d35a_tx(dev, everything, sizeof(everything), 0);
}

void ht16d35a_info(spi_device_handle_t dev) {
    char out[3] = { 0, 0, 0 };
    ht16d35a_tx(dev, out, sizeof(out), 0);
    //ht16d35a_wait();

    int datalen;
    //ht16d35a_rx(dev, buf, &datalen);

   // ESP_LOGI(TAG, "IDN (%d) '%s'", datalen, buf);
}